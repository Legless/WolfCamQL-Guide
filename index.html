<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<link href="styles/normalize.css" rel="stylesheet" type="text/css" />
		<link href="http://fonts.googleapis.com/css?family=Ubuntu+Mono|Scada|Play:700&amp;subset=latin,cyrillic,cyrillic-ext,latin-ext" rel="stylesheet" type="text/css" />
		<link href="styles/main.css" rel="stylesheet" type="text/css" />

		<title>Russian WolfCamQL Guide</title>

		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
		<script src="js/main.js"></script>
	</head>
	<body>
		<a href="https://github.com/Legless/WolfCamQL-Guide">
			<img style="position: fixed; top: 0; left: 0; border: 0; box-shadow: none;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_red_aa0000.png" alt="Fork me on GitHub" />
		</a>

		<a id="scrolltop" class="scroll-link" href="#nav">&uarr;</a>

		<div id="wrapper">
			<h1>Russian WolfCamQL Guide</h1>

			<section id="nav">
				<nav>
					<h2>Содержание</h2>
					<ul>
						<li><a href="#intro" class="scroll-link">Об этом руководстве</a></li>
						<li><a href="#about-wolfcam" class="scroll-link">О, WolfCam!</a></li>
						<li><a href="#install" class="scroll-link">Установка</a></li>
						<li><a href="#basic-setup" class="scroll-link">Базовая настройка</a></li>
						<li><a href="#viewing-demos" class="scroll-link">Использование для просмотра демо</a></li>
						<li><a href="#recording-video" class="scroll-link">Съёмка видео</a></li>
						<li><a href="#advanced-setup" class="scroll-link">Продвинутая настройка</a></li>
						<li><a href="#editing-demos" class="scroll-link">Работа с демо-файлами</a></li>
						<li><a href="#fx-system" class="scroll-link">FX-подсистема</a></li>
						<li><a href="#small-wiles" class="scroll-link">Небольшие хитрости</a></li>
						<li><a href="#faq" class="scroll-link">FAQ</a></li>
						<li><a href="#links" class="scroll-link">Ссылки</a></li>
						<li><a href="#epilogue" class="scroll-link">Послесловие</a></li>
					</ul>
				</nav>
			</section>

			<section id="about">
				<h2>Об этом руководстве</h2>
				<p>...</p>
			</section>

			<section id="about-wolfcam">
				<h2>О, WolfCam!</h2>
				<p>
					В старые добрые времена, когда Дум 3 был одной из самых ожидаемых игр, в стане Quake 3 Arena существовала программа для мувимейкинга. Это программа &mdash; легенда, и имя ей &mdash; <b>Quake 3 Movie Maker's Edition (q3mme)</b>.
				</p>
				<p>
					Прошли годы, Кармак решил возродить старушку Арену и скрестил её с бессмертным Интернетом и его Веб-браузерами. Пока он и его команда обновляли, меняли, добавляли разный контент в их воскрешенную игру, недалеко от них, в стане ванильщиков допиливали код Quake 3 Arena Point Release 1.32 и довели его до неоффициального 1.36. Они известны, их чадо зовется ioquake3.
				</p>
				<p>
					И вот, в один прекрасный день один прекрасный человек сделал WolfCamQL &mdash; изначально модифицированный ioquake для просмотра демо-файлов без установленного Quake Live, а сейчас &mdash; полноценный инструмент для муви-мейкинга, разросшийся сейчас до версии 9.2. Пока что это единственная программа, решившая продолжить путь q3mme в стане Quake Live.
				</p>
				<p>
					Он поддерживает 73-й протокол (а с версии 9.0 &mdash; ещё и обратный 68-й), скрипты, совместимые с q3mme и кучу всего, нужного и не очень для создания полноценного игрового видео.
				</p>
			</section>

			<section id="install">
				<h2>Установка</h2>
				<p>
					Установка этой замечательной программы очень проста: нужно только лишь скачать последнюю версию (на данный момент это <a href="http://www.gamefront.com/files/21897234/wolfcamql-9.2.zip">WolfCam 9.2</a>) и распаковать её куда-нибудь.
				</p>
				<p>
					После чего нужно скопировать из папки QuakeLive все паки. Для этого переходим в:
				</p>
				<ul>
					<li>Vista/7/8: <br /> <code>%AppData%\..\LocalLow\id Software\quakelive\baseq3</code></li>
					<li>XP: <br /> <code>%appdata%\id Software\quakelive\baseq3</code></li>
					<li>Linux: <br /> <code>~/.quakelive/quakelive/baseq3/</code></li>
					<li>OSX: <br /> <code>~/Library/Application/Support/Quakelive/baseq3/</code></li>
				</ul>
				<p>
					И копируем оттуда все файлы в папку /baseq3/ в директории, в которую распакован WolfCam.
				</p>
			</section>

			<section id="basic-setup">
				<h2>Базовая настройка</h2>
				<p>
					По-умолчанию WolfCam снимает видео на диск C:\. Что бы это исправить, необходимо запускать его с другими настройками. Для этого нужно создать файл *.bat, где написать:
					<code>
						start <i>путь_к_вульфкаму</i>\wolfcamql.exe +set fs_homepath "<i>путь_к_вульфкаму</i>"
					</code>
					После этого WolfCam будет сохрнять видео и скриншоты указанную директорию (в данном случае туда же, где лежит его exe-файл) в папки wolfcamql/videos/ и wolfcamql/screenshots/ соответственно. Запускать програму нужно будет именно этим файлом.
				</p>
				<p>
					Что бы настроить разрешение окна Вульфкама, необходимо использовать следующие три переменные:
					<code class="box">
						/r_mode -1 <br />
						/r_customWidth 1280 <br />
						/r_customHeight 720
					</code>
					Первая из них включает режим "ручной" подстановки рзрешения, а другие регулирует ширину и высоту окна соответственно.
					Изменения вступят силу после рестарта программы или использования команды <code>/vid_restart</code>.
				</p>
				<p>
					Современным стандартом качества является формат 16:9, однако никто не мешает вам использовать совершенно любое соотношение сторон.
				</p>
				<p>
					После установки нужного разрешения может случиться так, что HUD станет отображаться неправильно. Для исправления этого существет переменная <code>/cg_wideScreen x</code>, где x: <br />
					<b>0</b> &mdash; не делает ничего. <br/>
					<b>1</b> &mdash; рисует худ согласно прописанным координатам, не внося никаких изменений в них, в результате обычные, не подготовленные HUD-ы будут рисоваться в левом верхнем углу экрана. Стоит использовать только если худ сделан специально для использования с этой командой. <br/>
					<b>2</b> &mdash; увеличивает худ, сохраняя его стандартные (4:3) пропорции. <br/>
					<b>3</b> &mdash; растягивает худ согласно новых пропорций окна. Наиболее предпочтительная команда. <br/>
					<b>4</b> &mdash; пытается перестроить худ для новых пропорций. <br/>
				</p>
				<div class="clearfix img-box">
					<a href="images/screenshots/widescreen4.jpg" target="_blank"><img src="images/thumbs/widescreen4.jpg" width="300" height="169" alt="" /></a>
					<a href="images/screenshots/widescreen2.jpg" target="_blank"><img src="images/thumbs/widescreen2.jpg" width="300" height="169" alt="" /></a>
					<br />
					<a href="images/screenshots/widescreen3.jpg" target="_blank"><img src="images/thumbs/widescreen3.jpg" width="300" height="169" alt="" /></a>
					<a href="images/screenshots/widescreen1.jpg" target="_blank"><img src="images/thumbs/widescreen1.jpg" width="300" height="169" alt="" /></a>
				</div>
			</section>

			<section id="viewing-demos">
				<h2>Использование для просмотра демо</h2>
				<h3>Управление временем</h3>
				<p>
					Кроме использования команды <code>/timescale x</code> для ускорения и замедления воспроизведения демо файла в x раз, WolfCam позволяет использовать команду <code>/seekclock mm:ss</code> для перехода к нужному времени по игровому таймеру.
				</p>
				<p>
					Также существует команда <code>/fragforward</code>, при исполнении которой последовательно показываются все фраги, сделанные пишущим демо игроком. Остановить проход по фрагам можно, выполнив команду <code>/fragforward</code> ещё раз.
				</p>
				<p>
					Допускается регулирование времени, в течение которого будет показан фраг: <code>/fragforward время_до_фрага время_после_фрага</code>, например <code>/fragforward 2 0.5</code> покажет две секунды перед фрагом и пол секунды после него.

					<!-- Спасибо Печке за подсказку. -->
				</p>
			</section>

			<section id="recording-video">
				<h2>Съёмка видео</h2>
				<p>
					Перед съёмкой видео необходимо настройть количество FPS (кадров в секунду), делается это переменной <code>/cl_aviFrameRate fps</code>, где fps — любое число от 1 до 1000.
				</p>
				<p>
					Сама же запись видео производится командой
					<code>/video [params]</code>
					где <i>params</i> — параметры формата выходного видео. Возможные варианты вывода изобржения: png, tga, jpeg, avi, avins. Первые три на выходе дают <b>секвенцию</b> — последовательность файлов по одному на кадр. Два последних — один видеофайл в формате <b>losless</b> (несжатый, т.е., без потери качества) avi, содержащий все кадры сразу. Различие avi и avins в том, что последний не пишет звук в avi-файл.
				</p>
				<p>
					Добавить к снятому видео звук можно так же просто: всего лишь добавив <b>wav</b> к параметрам записи, например:
					<code class="box">/video avi wav</code>
				</p>

				<h3>Продвинутый захват (фрикамминг, переключение PoV-ов)</h3>
				<p>
					Кроме обычной съёмки WolfCam даёт возможность летать по карте как спектатор. Команда <code>/freecam</code> (по-умолчанию забиндена на Enter) включает и выключает режим фрикамминга, переменная <code>/cg_freecam_noclip 1|0</code> включает/выключает прохождение камеры сквозь стены.
				</p>
				<div class="img-wrapper">
					<a href="images/screenshots/enemys_pov.jpg" target="_blank"><img src="images/thumbs/enemys_pov.jpg" width="400" height="225" alt="" /></a>
				</div>
				<p>
					Кроме этого существует возможность смотреть демку от лица других игроков: сначала нужно узнать id игрока используя команду

					<code>/players</code>
					Вывод этой команды примерно такой:
					<code class="box">X 00 Cypher<br />
						  X 01 Cooller<br />
						  X 02 FanJibo</code>
					И для просмотре демки от другого лица остается лишь выполнить команду
					<code class="box">/follow <i>номер_игрока</i></code>

					В виду технической особенности демок QuakeLive, вы не сможете посмотреть моменты глазами игрока, который находится слишком далеко от снимающего демку.
				</p>

				<h4>Продвинутые техники создания камер</h4>
				<div class="img-wrapper">
					<a href="images/screenshots/camera_point_info.jpg" target="_blank"><img src="images/thumbs/camera_point_info.jpg" width="400" height="225" alt="" /></a>
					<a href="images/screenshots/camera_path.jpg" target="_blank"><img src="images/thumbs/camera_path.jpg" width="400" height="225" alt="" /></a>
				</div>
				<p>
					Кроме возможности просто полетать камерой по карте (управляя её дрожжащей рукой), управление полётом камеры можно повесить на WolfCam, задав только нужные ключевые точки. В свою очередь програма красиво интерполирует полёт по времени.
				</p>
				<p>
					Для этого нужно, во-первых, перейти в режим фрикамминга, после чего создать первую точку пути, вызвав команду <code>/addcamerapoint</code>.
					Желательно включить отображение информации о пути и точках с помощью команд
					<code class="box">
						/cg_drawCameraPointInfo 1<br />
						/cg_drawCameraPath 1
					</code>
					После этого можно создав весь путь, выставляя ключевые точки там, где нужно с помощью этой же команды.
				</p>
				<p>
					Проиграть полученный путь можно с помощью команды <code>/playcamera</code>	, удалить &mdash; <code>/clearcamerapoints</code>.
				</p>

				<h4>Продвинутые пути</h4>
				<p>...</p>
			</section>

			<section id="advanced-setup">
				<h2>Продвинутая настройка</h2>
				<h3>Цветные искры</h3>
				<div class="img-wrapper">
					<a href="images/screenshots/coloredSparks.jpg" target="_blank"><img src="images/thumbs/coloredSparks.jpg" width="400" height="225" alt="" /></a>
				</div>
				<p>
					Начиная с версии 7.2 Wolfcam позволяет менять цвет искр переменной <code>/cg_gibSparksColor</code>.
					Переменная хранит hex-код цвета (например, 0xFF0000 — это красный, 0xFFFFFF — белый, etc).
				</p>
				<p>
					Переменная <code>cg_gibSparksHighlight</code> включает и выключает маленькую белую точку (подсветку) в середине каждой искры.
				</p>
				<p>
					<code>/cg_impactSparksColor</code> меняет цвет искр, появляющихся при попадании в противника.
				</p>

				<br />
				<br />

				<h3>Мясо из Q3</h3>
				<div class="img-wrapper">
					<a href="images/screenshots/q3gibs.jpg" target="_blank"><img src="images/thumbs/q3gibs.jpg" width="400" height="225" alt="" /></a>
				</div>
				<p>
					Те, кому надоели гламурные искры из QL, могут воспользоваться возможностью включить мясо (гибсы) из Q3.
				</p>
				<p>
					Для этого нужно скопировать следующие файлы из pak0 Quake3:
					<code class="box">
						gfx/damage/blood_spurt.tga<br />
						gfx/damage/blood_stain.tga<br />
						models/gibs/gibs.jpg<br />
						models/gibs/leg.md3<br />
						models/gibs/skull.md3<br />
						models/gibs/abdomen.md3<br />
						models/gibs/chest.md3<br />
						models/gibs/intestine.md3<br />
						models/gibs/brain.md3<br />
						models/gibs/foot.md3<br />
						models/gibs/forearm.md3<br />
						models/gibs/arm.md3<br />
						models/gibs/fist.md3<br />
						sound/player/gibimp1.wav<br />
						sound/player/gibimp2.wav<br />
						sound/player/gibimp3.wav<br />
						sound/player/gibsplt1.wav<br />
					</code>
					И поместить их соответственно в:
					<code class="box">
						wolfcamql/wolfcam-ql/gfx/damageq3/blood_spurt.tga<br />
						wolfcamql/wolfcam-ql/gfx/damageq3/blood_stain.tga<br />
						wolfcamql/wolfcam-ql/models/gibsq3/gibs.jpg<br />
						wolfcamql/wolfcam-ql/models/gibsq3/leg.md3<br />
						wolfcamql/wolfcam-ql/models/gibsq3/skull.md3<br />
						wolfcamql/wolfcam-ql/models/gibsq3/abdomen.md3<br />
						wolfcamql/wolfcam-ql/models/gibsq3/chest.md3<br />
						wolfcamql/wolfcam-ql/models/gibsq3/intestine.md3<br />
						wolfcamql/wolfcam-ql/models/gibsq3/brain.md3<br />
						wolfcamql/wolfcam-ql/models/gibsq3/foot.md3<br />
						wolfcamql/wolfcam-ql/models/gibsq3/forearm.md3<br />
						wolfcamql/wolfcam-ql/models/gibsq3/arm.md3<br />
						wolfcamql/wolfcam-ql/models/gibsq3/fist.md3<br />
						wolfcamql/wolfcam-ql/sound/player/gibimp1.wav<br />
						wolfcamql/wolfcam-ql/sound/player/gibimp2.wav<br />
						wolfcamql/wolfcam-ql/sound/player/gibimp3.wav<br />
						wolfcamql/wolfcam-ql/sound/player/gibsplt1.wav<br />
					</code>
				</p>
				<p>
					Гибсы включаются переменной <code>/cl_enableQ3Gibs 1</code>.
				</p>

				<h3>Нестандартные модели</h3>
				<div class="img-wrapper">
					<a href="images/screenshots/custommodels.jpg" target="_blank"><img src="images/thumbs/custommodels.jpg" width="400" height="225" alt="" /></a>
				</div>
				<p>
					В Вульфкаме очень просто использовать нестандартные модели, текстуры и звуки: для них не требуется перепаковка, шифровка или конвертция.
					Готовые pak-и, созданные для QL/Q3 нужно копировать в папку <code>/baseq3/</code>, отдельные файлы — в папку <code>/wolfcam-ql/</code>, сохраняя вложенность каталогов.
				</p>
				<p>
					Wolfcam (как и Q3/QL) грузит паки в алфавитном порядке их нзваний, так что заменяющие паки желательно делать с префиксом из нескольких букв z, например <code>zz-mypack.pk3</code>.
					Файлы из папки <code>/wolfcam-ql/</code> он грузит в последнюю очередь.
				</p>

				<br />

				<h3>Depth of Field</h3>
				<div class="img-wrapper">
					<a href="images/screenshots/dof.jpg" target="_blank"><img src="images/thumbs/dof.jpg" width="400" height="225" alt="" /></a>
				</div>
				<p>
					Depth of Field (а по-русски "глубна резкости") — это, по сути, размытие всех объектов, которые находятся дальше определённого расстояния от точки фокуса камеры. Поддержка этого отличного эффекта в вульфкаме заключается всего в одной переменной — <code>/mme_saveDepth 1</code>, которая включает запись второго видеоряда, включающего в себя только Z-Buffer (буфер глубины, интенсивность пикселей которого зависит от расстояния до камеры) в том же формате, что и основное видео (секвенция картинок или avi-файл).
				</p>
				<p>
					После захвата полученное видео необходимо обработать для, собственно, включения DoF. Я покажу это на примере Adobe After Effects.
				</p>
				<p>
					Делается это очень просто: берём оба видео и создаём новую композицию с ними так, что бы видео с depth-буффером было снизу.
				</p>
				<div class="img-box">
					<img src="images/screenshots/dof-ae-1.png" width="589" height="92" alt="" />
				</div>
				<p>
					К верхнему, цветному видео применяем эффект Lens Blur, указав в качестве параметра <b>Depth Map Layer</b> слой с Z-буффером.
				</p>
				<div class="img-box">
					<img src="images/screenshots/dof-ae-2.png" width="364" height="187" alt="" />
				</div>
				<p>
					При необходимости, регулруем фокус параметром <b>Blur Focal Distance</b>, силу размытия &mdash; <b>Iris Radius</b> и форму боке — <b>Iris Shape</b>.
				</p>

				<h3>Встроенный motion blur</h3>
				<p>...</p>

				<h3>Bloom и цветокоррекция</h3>
				<div class="img-wrapper">
					<a href="images/screenshots/bloom_disabled.jpg" target="_blank"><img src="images/thumbs/bloom_disabled.jpg" width="400" height="225" alt="" /></a>
					<a href="images/screenshots/bloom_enabled.jpg" target="_blank"><img src="images/thumbs/bloom_enabled.jpg" width="400" height="225" alt="" /></a>
				</div>
				<p>
					Bloom (блум) &mdash; это один из эффектов постобработки, который делает яркие части изображения ещё ярче, создавая вокруг них свечение.
					Принцип работы блума заключается в следующем:
				</p>
				<ol>
					<li>Текущий кадр сохраняется в отдельную текстуру</li>
					<li>Отсекаются недостаточные по яркости пиксели</li>
					<li>Текстура размывается</li>
					<li>Выолняется цветокоррекция исходного кадра и текстуры блума: изменяются их насыщенности и яркости</li>
					<li>Размытая текстура блума складывается с текущим кадром</li>
				</ol>
				<p>
					В Вульфкаме блум включается перемкнной <code>/r_enableBloom 1</code>, и регулируется следующими переменными:
					<code class="box">
						<b>/r_bloomPasses</b> &mdash; количество проходов блума для одного кадра (больше &mdash; сильнее эффект)<br />
						<b>/r_bloomSceneIntensity</b> &mdash; яркость сцены (базового кадра) <br />
						<b>/r_bloomSaturation</b> &mdash; насыщенность сцены <br />
						<b>/r_bloomIntensity</b> &mdash; яркость блума <br />
						<b>/r_bloomSaturation</b> &mdash; насыщенность блума <br />
						<b>/r_bloomBrightThreshold</b> &mdash; порог яркости пикселя для обретания блума <br />
						<b>/r_bloomTextureScale</b> &mdash; соотношение размера текстуры блума к размеру кадра <br />
						<b>/r_bloomDebug</b> &mdash; отладка: отрисовка блума в отдельном "окне", не накладывая его на сцену <br />
					</code>
				</p>
			</section>

			<section id="editing-demos">
				<h2>Работа с демо-файлами</h2>
				<h3>Нарезка демо-файлов</h3>
				<p>
					WolfCam позволяет вырезать небольшой кусок из большого демо-файла используя команду <code>/record</code> во время просмотра. Для удобства желательно использовать следующие бинды:
					<code class="box">
						/bind n "pause; record" <br />
						/bind m "stoprecord"
					</code>
				</p>
				<p>
					После нажатия клавиши <b>m</b> проигрывание демо станет на паузу, а после возобновления пригрывания начнёт записываться новый демо-файл, содержащий нужный кусок.
				</p>

				<h3>Использование демо 68-го протокола (Quake 3 Arena)</h3>
				<p>
					Начиная с версии 9.0 в Вульфкаме появилась поддержка протокола Quake 3 Arena. Для её включения нужно скопировать нужные паки Q3 в директорию /baseq3/ и запустить WolfCam следующим образом (см. раздел "Базовая настройка"):
					<code class="box">
						wolfcamql.exe +set protocol 68
					</code>
				</p>
			</section>

			<section id="fx-system">
				<h2>FX-подсистема</h2>
				<p>
					FX-скрипты используются вульфкамом для кастомизации некоторых событий в сцене. В Q3/QL все эти эфекты жестко заданы в исходном коде, так что для их изменения необходима перекомпиляция движка. Wolfcam (и q3mme) может привязывать скрипты к определённым игровым событиям (взырвы снарядов) и сущностям (игроки и снаряды). Эти скрипты могут быть перезаписаны под свои нужды.
				</p>
				<p>
					Переменная <code>/cg_fxfile</code> содержит название и путь к файлу с эффектами. Перезагружаются скрипты командой <code>/fxload</code>.
				</p>

				<h3>Пример скрипта</h3>
					<p>
						Пример скрипта, вызываемого когда игрок чатится:
						<code class="box">
							player/talk {<br />
							size		10<br />
							shader		sprites/balloon3<br />
							Sprite<br />
							}
						</code>

						Во-первых, <code>player/talk</code> &mdash; это название скрипта, которое говорит игре, к какому событию его привязывать. Все названия перечислены ниже. Далее в фигурных скобках идет тело скрипта. Код присваивает значение переменным, означающим размер и шейдер сущности, и вызывает команду <code>sprite</code>, рисующую в сцене картинку, повёрнутую к камере (спрайт), используя переменные <code>size</code> (размер), <code>shader</code> (шейдер) и <code>origin</code> (положение в пространстве). Хоть переменная <code>origin</code> и не задана в теле скрипта, она передаётся в него движком Вульфкама.
					</p>

				<h3>Названия скриптов</h3>
					<p>
						Каждое событие, которое обрабатывается fx-подсистемой, привязано к определённому названий скрипта. Ниже находится список этих названий, описание события, вызывающего их и список аргументом, передаваемых в скрипт. 
					</p>

					<table>
						<tr><th colspan="3">События для оружия</th></tr>
						<tr><th>Название</th>
							<th>Событие</th>
							<th>Аргументы</th></tr>
						<tr><th>weapon/X/flash</th>
							<td>Вызывается каждый фрейм в течение 25 мс. после выстрела оружия</td>
							<td>origin, velocity, axis, life</td></tr>
						<tr><th>weapon/X/fire</th>
							<td>Вызывается один раз при выстреле из оружия</td>
							<td>origin, direction, velocity</td></tr>
						<tr><th>weapon/X/impact</th>
							<td>Пуля достигла стены или взорвался снаряд</td>
							<td>origin, direction</td></tr>
						<tr><th>weapon/X/impactflesh</th>
							<td>Пуля или снаряд попали в игрока</td>
							<td>origin, direction</td></tr>
						<tr><th>weapon/X/projectile</th>
							<td>Вызывается каждый фрейм для снарядов</td>
							<td>origin, velocity, direction, angles</td></tr>
						<tr><th>weapon/X/trail</th>
							<td>Вызывается каждый фрейм для снарядов или единожды для hitscan-оружия</td>
							<td>origin, velocity, axis, life</td></tr>
						<tr><th>weapon/X/bubbles</th>
							<td>Вызывается при выстреле из оружия под водой</td>
							<td>origin</td></tr>
						<tr><th>common/jumpPad</th>
							<td>Игрок коснулся джамппада</td>
							<td>origin</td></tr>
						<tr><th>common/headShot</th>
							<td>В игрока попали headshot</td>
							<td>origin</td></tr>							
					</table>

					<p>
						На месте <b>x</b> в этих скриптах может находится любое из следующих оружий: 
						<code>common (для всех оружий), rocket, rail, grenade, machinegun, shotgun, plasma, bfg, gauntlet, lightning, grapple.</code>
					</p>


					<table>
						<tr><th colspan="3">Другие события</th></tr>
						<tr><th>Название</th>
							<th>Событие</th>
							<th>Аргументы</th></tr>
						<tr><th>player/gibbed</th>
							<td>Игрок убит, и его труп должен взорваться</td>
							<td>origin, velocity</td></tr>
						<tr><th>player/thawed</th>
							<td>Игрока разморозили в режиме Freeze Tag</td>
							<td>origin, velocity</td></tr>
						<tr><th>player/teleportIn</th>
							<td>Игрок входит в телепорт</td>
							<td>origin</td></tr>
						<tr><th>player/teleportOut</th>
							<td>Выходит из телепорта</td>
							<td>origin</td></tr>
						<tr><th>player/haste, <br />
								player/flight</th>
							<td>У игрока активнен соответствующий Power-Up</td>
							<td>origin</td></tr>
						<tr><th>player/talk</th>
							<td>Игрок открыл чат</td>
							<td>origin</td></tr>
						<tr><th>player/connection</th>
							<td>Игрок завис</td>
							<td>origin</td></tr>
						<tr><th>player/impressive, <br /> 
								player/excellent, <br /> 
								player/gauntlet, <br /> 
								player/capture, <br /> 
								player/assist</th>
							<td>Игрок получил соответствующую медаль</td>
							<td>origin</td></tr>
						<tr><th>player/head/trail, <br /> 
								player/torso/trail, <br /> 
								player/legs/trail</th>
							<td>Выполняется каждый фрейм для соответствующей части тела каждого игрока</td>
							<td>origin</td></tr>
					</table>

				<h3>Команды</h3>
					<p>
						Команды фактически добавляют в сцену эффекты, такие как звук, модели, спрайты и т.д. Остальные строки скрипта всего-лишь настраивают параметры команд.
					</p>
					<dl>
						<dt>Sprite</dt>
						<dd>
							Добавляет в сцену квадратный полигон, всегда повёрнутый к камере. <br />
							Аргументы: <code>renderfx</code>. <br />
							Используемые переменные: <code>origin, shader, size, angle, color</code>.
						</dd>

						<dt>Quad</dt>
						<dd>
							Добавляет в сцену полигон, нормаль которого направлена по вектору <code>dir</code>. <br />
							Аргументы: <code>renderfx</code>. <br />
							Используемые переменные: <code>origin, shader, size, angle, color</code>.
						</dd>

						<dt>Beam</dt>
						<dd>
							Используется для эффектов рейлгана и шафта. Шейдер растянут между <code>origin</code> и <code>origin+dir</code>. Толщина луча установлена в <code>size</code>. Луч всегда повёрнут к камере. <br />
							Используемые переменные: <code>origin, dir, shader, size, angle, color</code>.
						</dd>

						<dt>Spark</dt>
						<dd>
							Добавляет "искорку" — прямоугольный полигон, повёрнутый к камере. Его длинна выставляется переменной <code>size</code>, ширина &mdash; <code>width</code>. Один из концов направлен по вектору <code>velocity</code>.<br />
							Используемые переменные: <code>origin, velocity, size, width, shader, color</code>.
						</dd>

						<dt>Decal</dt>
						<dd>
							Декали используютя для помещения шейдера на поверхности карты. Шейдер остаётся на поверхности в течение <code>life</code> милисекунд. Деколь центрирована по вектору <code>origin</code>, её нормаль направлена по <code>dir</code>.<br />
							Аргументы: <code>life</code> &mdash; время жизни деколи в милисекундах. <br />
							Используемые переменные: <code>origin, shader, dir, color, rotate, size</code>.
						</dd>

						<dt>dirModel</dt>
						<dd>
							Добавляет в сцену модель, заданную в переменной <code>model</code>, направленную по вектору <code>dir</code>.<br />
							Используемые переменные: <code>origin, dir, model, shader, rotate, size, color</code>.
						</dd>

						<dt>Light</dt>
						<dd>
							Добавляет в сцену свет в позиции <code>origin</code>.<br />
							Используемые переменные: <code>origin, size, color </code>.
						</dd>

						<dt>Sound</dt>
						<dd>
							Проигрывает звук <code>soundname</code>.<br />
							Аргументы: <code>soundname</code>.<br />
							Используемые переменные: <code>origin</code>
						</dd>

						<dt>loopSound</dt>
						<dd>
							Проигрывает звук <code>soundname</code> в бесконечном цикле.<br />
							Аргументы: <code>soundname</code>.<br />
							Используемые переменные: <code>origin</code>
						</dd>

						<dt>Vibrate</dt>
						<dd>
							Создаёт вибрацию камеры с силой <code>strength</code> в точке <code>origin</code>.<br />
							Аргументы: <code>strength</code>.<br />
							Используемые переменные: <code>origin</code>.
						</dd>
					</dl>


				<h3>Блоки</h3>
					<dl>
						<dt>repeat (math) { ... }</dt>
						<dd>Выполняет блок кода <code>math</code> раз, в теченее которых переменная <code>loop</code> изменяется от 0 до 1.</dd>

						<dt>emitter (math) { ... }</dt>
						<dd>Любая сущность, созданная в этом блоке, будет жить в теченее <code>math</code> секунд. Переменная <code>life</code> хранит её время жизни в секундах, <code>lerp</code> &mdash; стремится от 0 до 1 в теченее её жизни.</dd>

						<dt>if (math) { ... }</dt>
						<dd>Выполняет блок кода только если условие <code>math</code> истинно (не равно нолю).</dd>

						<dt>once { ... }</dt>
						<dd>Выполняет блок кода только едножды, не зависимо от того, сколько раз был вызван данный кусок кода.</dd>

						<dt>distance (math) { ... }</dt>
						<dd>Выполняет блок кода через каждые <code>math</code> юнитов расстояния. Не имеет смысла в событийных скриптах (таких, как <code>weapon/impact</code>) и должен использоваться только в событиях типа <code>weapon/trail</code>.</dd>

						<dt>interval (math) { ... }</dt>
						<dd>Выполняет блок кода каждые <code>math</code> секунд. Как и предыдущий блок, не имеет смысла в событийных скриптах.</dd>

						<dt>shaderList (math) { ... }, modelList (math) { ... }, soundList (math) { ... }, colorList (math) { ... }</dt>
						<dd>Блок содержит список шейдеров, моделей, звуков или цветов соответственно, элемент списка c номером <code>math</code> назначается соответствующей переменной.</dd>

						<dt>colorBlend (math) { ... }</dt>
						<dd>То же, что и <code>colorList</code>, но выбирается не ближайший к номеру <code>math</code> цвет, а цвета интерполируются.</dd>
					</dl>

				<h3>Переменные</h3>
					<p>
						Переменные создают контекст для скриптовых комманд. Бывают трёх типов: вещественные, векторные и строковые.
						Кроме переменных fx-подсистемы есть доступ ко всем переменным вульфкама по их имени.
					</p>
				
				<h4>Вещественные</h4>				
					<dl>
						<dt>colorFade</dt>
						<dd>Задаёт точку, начиная с которой цвет сущности начинает стремиться к [0;0;0].</dd>

						<dt>alphaFade</dt>
						<dd>То же самое для прозрачности.</dd>

						<dt>colorScale</dt>
						<dt>colorHue</dt>
						<dd>...</dd>
						
						<dt>red, green, blue, alpha</dt>
						<dd>Компоненты цвета сущности.</dd>

						<dt>size</dt>
						<dd>Размер сущности</dd>

						<dt>width</dt>
						<dd>Ширина сущности</dd>

						<dt>t0 ... t9</dt>
						<dd>Временные переменные для сохранения промежуточных значений. Не влияют ни на что.</dd>
					</dl>

				<h4>Векторные</h4>				
					<dl>
						<dt>origin</dt>
						<dd>Положение сущности в пространстве.</dd>

						<dt>velocity</dt>
						<dd>Линейная скорость сущности: значение этого вектора каждый кадр прибавляется к <code>origin</code>.</dd>

						<dt>angles</dt>
						<dd>Углы поворота сущности относительно [0;0;0].</dd>

						<dt>dir</dt>
						<dd>Направление сущности. </dd>

						<dt>parentOrigin</dt>
						<dt>parentVelocity</dt>
						<dt>parentAngles</dt>
						<dt>parentDir</dt>
						<dd>...</dd>

						<dt>color</dt>
						<dd>Цвет вершн сущности.</dd>

						<dt>v0 ... v9</dt>
						<dd>Временные переменные для сохранения промежуточных значений. Не влияют ни на что.</dd>
					</dl>
					

				<h4>Строковые</h4>				
					<dl>
						<dt>shader</dt>
						<dd>Шейдер, накладываемый на сущность.</dd>

						<dt>model</dt>
						<dd>Модель для отрисовки.</dd>

						<dt>script</dt>
						<dd>...</dd>
					</dl>

				<h4>Специальные ключевые слова</h4>
					<dl>moveGravity floatGravity</dl>
					<dd>Наделяет сущность гравитацией.</dd>

					<dl>moveBounce floatGravity floatFactor </dl>
					<dd>То же, что и предыдущее, но сущность отскакивает от поверхностей, сохраняя <code>floatFactor</code> первоначальной скорости.</dd>

					<dl>impactDeath floatGravity</dl>
					<dd>То же, что и предыдущее, но сущность исчезает при столкновении с поверхностью.</dd>

					<dl>sink floatDelay floatDepth</dl>
					<dd>Сущность "впадает" в поверхности на глубину <code>floatDepth</code> с задержкой <code>floatDelay</code>.</dd>

					<dl>shaderClear</dl>
					<dd>Очищает шейдер.</dd>

					<dl>push, pop, pushparent</dl>
					<dd>...</dd>


				<h3>Математика</h3>
				<h4>Вещественная математика</h4>
				<p>
					Выражение, дающие на выходе вещественное число, может содержать любые консольные переменные, вещественные переменные fx-системы, арифметические операторы (+, -, *, /), операторы сравнения (=, !, &lt;, &gt;) и операторы булевой алгебры (&amp;, |). Доступны следующие алгебраические функции:
				</p>

				<dl>
					<dt>sqrt( x )</dt>
					<dd>Возвращает квадратный корень из <code>x</code>.</dd>

					<dt>ceil( x ), floor( x )</dt>
					<dd>Округление <code>x</code> до близжайшего целого вверх и вниз соответственно</dd>

					<dt>sin( x ), cos( x )</dt>
					<dd>Синус и косинус</dd>

					<dt>clip( x )</dt>
					<dd>Приводит число <code>x</code> к отрезку [0;1] так, что значения меньше ноля становятся нолём, а больше единицы &mdash; единицей.</dd>

					<dt>rand, crand</dt>
					<dd>Возвращают случайное число от -1 до 1 и от 0 до 1 соответственно.</dd>
				</dl>

				<h4>Математика с векторами</h4>
				<p>
					Вектор представляет собой трёхмерный массив вещественных чисел.	Для доступа к отдельным его компонентам после имени вектора нужно поставить номер координаты, например
					<code>origin0</code> возвращает абсциссу. При использовании вектора в качестве вещественного числа будет возвращаться его длина, например:
					<code class="box">
						size dir // Размер становится равным длинне вектора dir
					</code>
				</p>
				<p>
					Как и для вещественных чисел, для векторов доступны некоторые функции: 
				</p>

				<dl>
					<dt>copy vSrc vDst</dt>
					<dd>Копирует <code>vSrc</code> в <code>vDst</code>.</dd>

					<dt>scale vSrc vDst floatX</dt>
					<dd><code>vDst = vSrc * floatX</code></dd>

					<dt>sub vSrc1 vSrcs vDst</dt>
					<dd><code>vDst = vSrc1 - vSrc2</code></dd>

					<dt>add vSrc1 vSrc1 vDst</dt>
					<dd><code>vDst = vSrc1 + vSrc2</code></dd>

					<dt>addScale vSrc1 vSrc2 vDst floatX</dt>
					<dd><code>vDst = vSrc1 + vSrc2 * floatX</code></dd>

					<dt>subScale vSrc1 vSrc2 vDst floatX</dt>
					<dd><code>vDst = vSrc1 - floatX* vSrc2</code></dd>

					<dt>rotateAround vSrc vDir vDst floatX</dt>
					<dd>Вращает точку <code>vSrc</code> на <code>floatX</code> градусов вокруг <code>vDir</code> и сохраняет её новую позицию в <code>vDst</code>.</dd>

					<dt>wobble vSrc vDst floatX</dt>
					<dd>Перемещает точку <code>vSrc</code> по поверхности конуса с углом <code>floatX</code>.</dd>

					<dt>inverse vSrc [vDst]</dt>
					<dd>vDst = vSrc * -1. Если параметр <code>vDst</code> не задан, то результат сохранятся в <code>vSrc</code>.</dd>	

					<dt>normalize vSrc [vDst]</dt>
					<dd>Нормализирует вектор <code>vSrc</code>.</dd>

					<dt>perpendicular vSrc [vDst]</dt>
					<dd>Находит вектор, перпендикулярный <code>vSrc</code>.</dd>

					<dt>clear vSrc</dt>
					<dd><code>vSrc = (0, 0, 0)</code></dd>

					<dt>random vDst</dt>
					<dd>Записывает случайные значения из диапазона [0;1] в компоненты вектора.</dd>
				</dl>    
			</section>

			<section id="small-wiles">
				<h2>Небольшие хитрости</h2>
				<p>...</p>
			</section>

			<section id="faq">
				<h2>FAQ</h2>
				<p>...</p>
			</section>

			<section id="links">
				<h2>Ссылки</h2>
				<p>...</p>
			</section>

			<section id="epilogue">
				<h2>Послесловие</h2>
				<p>...</p>
			</section>
		</div>
	</body>
</html>
